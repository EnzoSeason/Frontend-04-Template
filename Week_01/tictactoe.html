<style>
    .cell {
        display: inline-block;
        height: 100px;
        width: 100px;
        margin: 20px;
        background-color: white;
        border: solid 1px black;
        border-radius: 50%;
    }
</style>

<div id="board"></div>

<script>
    const COLORS = ["white", "red", "green"];
    // nb of row and col
    let row = 3; 
    // nb of places
    let size = row * row;
    let winCondition = 3;
    
    
    let status = Array(size).fill(0);
    let player = 1;

    function init() {
        row = prompt('Number of the row / column of TicTacToe: ', [row]);
        size = row * row;
        status = Array(size).fill(0);
        winCondition = prompt('win condition (number of connected points): ', [winCondition]);
        
        let board = document.getElementById("board");

        for (let i = 0; i < size; i ++) {
            let cell = document.createElement("div");
            cell.setAttribute("id", `${i}`);
            cell.classList.add("cell");
            cell.style.backgroundColor = COLORS[0];
            cell.addEventListener("click", () => move(i));

            board.appendChild(cell);

            if ((i + 1) % row === 0) {
                board.appendChild(document.createElement("br"));
            }
        }
            
    }

    function move(i) {
        if (status[i] === 0) {
            let cell = document.getElementById(`${i}`);
            cell.style.backgroundColor = COLORS[player];

            status[i] = player;
            if (isWin(status, player, i)) {
                alert(`Player ${COLORS[player]} wins !`);
            }
            switchPlayer();
        } else {
            alert("Please choose another place.");
        }
    }
    
    function isWin(status, player, pos) {
        let i = parseInt(pos / row); 
        let j = pos % row;
        let pattern = [];
        
        // horizontal check
        for (let step = 0; step + 2 < row; step++) {
            pattern = createPattern(step, i, j, 1);
            if (check(status, pattern, player)){
                return true;
            }
        }

        // vec check
        for (let step = 0; step + 2 < row; step++) {
            pattern = createPattern(step, i, j, 2);
            if (check(status, pattern, player)){
                return true;
            }
        }

        // diag check
        // j = i + (y - x)
        for (let step = 0; step + 2 < row; step++) {
            pattern = createPattern(step, i, j, 3);
            if (check(status, pattern, player)){
                return true;
            }
        }
        // j = -i + (y + x)
        for (let step = 0; step + 2 < row; step++) {
            pattern = createPattern(step, i, j, 4);
            if (check(status, pattern, player)){
                return true;
            }
        }

        return false;
    }

    // helper functions

    function switchPlayer() {
        player = 3 - player;
    }

    function check(status, pattern, player) {
        for (let index of pattern) {
            if (index < 0 || index > size) {
                return false;
            }
            if (status[index] !== player) {
                return false;
            }
        }
        return true;
    }

    function createPattern(step, i, j, type) {
        let pattern = [];

        // horizontal
        // x = i
        if (type === 1) {
            for (let slide = 0; slide < winCondition; slide ++) {
                pattern.push(i * row + (step + slide));
            }
        }

        // vertical
        // y = j
        if (type === 2) {
            for (let slide = 0; slide < winCondition; slide ++) {
                pattern.push((step + slide) * row + j);
            }
        }

        // diag 1
        // y = x + (j - i)
        if (type === 3) {
            for (let slide = 0; slide < winCondition; slide ++) {
                pattern.push((step + slide) * row + (step + slide + j - i));
            }
        }

        // diag 2
        // y = -x + (j + i)
        if (type === 4) {
            for (let slide = 0; slide < winCondition; slide ++) {
                pattern.push((step + slide) * row + (-step - slide + j + i));
            }
        }

        return pattern;
    }

    // run code
    init();
</script>