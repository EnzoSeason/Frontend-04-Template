<style>
    .cell {
        display: inline-block;
        height: 100px;
        width: 100px;
        margin: 20px;
        background-color: white;
        border: solid 1px black;
        border-radius: 50%;
    }
</style>

<div id="board"></div>

<script>
    // nb of row and col
    const ROW = 4; 
    // nb of places
    const SIZE = ROW * ROW;
    const COLORS = ["white", "red", "green"];
    
    let status = Array(SIZE).fill(0);
    let player = 1;

    function init() {
        let board = document.getElementById("board");

        for (let i = 0; i < SIZE; i ++) {
            let cell = document.createElement("div");
            cell.setAttribute("id", `${i}`);
            cell.classList.add("cell");
            cell.style.backgroundColor = COLORS[0];
            cell.addEventListener("click", () => move(i));

            board.appendChild(cell);

            if ((i + 1) % ROW === 0) {
                board.appendChild(document.createElement("br"));
            }
        }
            
    }

    function switchPlayer() {
        player = 3 - player;
    }

    function move(i) {
        if (status[i] === 0) {
            let cell = document.getElementById(`${i}`);
            cell.style.backgroundColor = COLORS[player];

            status[i] = player;
            if (isWin(status, player, i)) {
                alert(`Player ${COLORS[player]} wins !`);
            }
            switchPlayer();
        } else {
            alert("Please choose another place.");
        }
    }
    
    function check(status, pattern, player) {
        for (let index of pattern) {
            if (index < 0 || index > SIZE) {
                return false;
            }
            if (status[index] !== player) {
                return false;
            }
        }
        return true;
    }
    
    function isWin(status, player, pos) {
        let x = parseInt(pos / ROW); 
        let y = pos % ROW;
        let pattern = [];
        
        // horizon check
        for (let step = 0; step + 2 < ROW; step++) {
            pattern = [x * ROW + step, x * ROW + (step + 1), x * ROW + (step + 2)];
            if (check(status, pattern, player)){
                return true;
            }
        }

        // vec check
        for (let step = 0; step + 2 < ROW; step++) {
            pattern = [step * ROW + y, (step + 1) * ROW + y, (step + 2) * ROW + y];
            if (check(status, pattern, player)){
                return true;
            }
        }

        // diag check
        // j = i + (y - x)
        for (let step = 0; step + 2 < ROW; step++) {
            pattern = [step * ROW + (step + y - x), (step + 1) * ROW + (step + 1 + y - x), (step + 2) * ROW + (step + 2 + y - x)];
            console.log(pattern);
            if (check(status, pattern, player)){
                return true;
            }
        }
        // j = -i + (y + x)
        for (let step = 0; step + 2 < ROW; step++) {
            pattern = [step * ROW + (-step + y + x), (step + 1) * ROW + (-step - 1 + y + x), (step + 2) * ROW + (- step - 2 + y + x)];
            console.log(pattern);
            if (check(status, pattern, player)){
                return true;
            }
        }

        return false;
    }

    init();
</script>