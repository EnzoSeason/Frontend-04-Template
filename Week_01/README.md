# 总结

## TicTacToe

1. 实现三子棋的人机对战和人人对战。

2. 实现多子棋（连子数自定义）在 N * N （自定义）棋盘的人人对战

通过这个项目， 学习了js对DOM的简单操作，简单的CSS布局。

### 项目亮点

1. 创建判断是否胜利的评估函数（Evaluation Function）

2. 使用MiniMax算法，创建三子棋的“AI”

### 评估函数

游戏胜利条件是，在一条**直线**上达成3个棋子**相连**。 由此建立评估函数。步骤如下：

1. 建立直角坐标系， 由此确定直线：以[0, 0]为原点， 从上之下为X轴， 从左到右为Y轴

2. 确定直线：假设落子的坐标为[i, j]， 则有4条直线可能达到胜利条件， 分别是:
    
    * x = i
    * y = j
    * y = x + j - i
    * y = -x + j + i

3. 画直线：保证直线不能超出棋盘， 把直线所在的点添加到数组内。

4. 找3连： 创建长度为3的窗口，如果发现窗口内的棋子都是当前玩家的棋子，则当前玩家胜利。如果窗口长度小于3，则当前还未胜利。

### MiniMax 算法

我理解的老师的算法是： 如果下一步棋能直接赢，就下这一步。 如果不能，下**所有**空的位置来寻找对手下一步**最有可能**赢的位置， 然后堵上它。

* 决策优化：添加**深度**惩罚。如果“AI”**先**发现一个位置能使**4步内**对手获胜， **后**发现发现一个位置能使**2步内**对手获胜。老师的算法是下在前者的位置，因为后者的落子得分和前者一致，就无法覆盖前者的落子位置。添加深度惩罚后，后者的落子得分比前者比前者高，就能下在后者位置。这样的决策更合理。

* 性能优化： 无。 每次递归，依然需要遍历所有的空的位置。非常糟糕

* 致命缺点： 不收敛。可能永远都找不到其中一方可以获胜的棋局。（4*4， 3连子的局就不收敛了）
