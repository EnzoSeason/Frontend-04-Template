# KMP

## 目标

KMP是一种模式匹配的算法，用来查找字符串（S）中的给定字符串（W）。

最简单的做法就是暴力求解，但如果字符串不是随机生成， 比如 S= (a*1000000)b, W = (a*1000)b。S中的a最多会被重复查询1000次。

KMP能对此优化。当查W到第1001项时，发现不匹配。暴力求解会从W的第**2**项开始重新查。但KMP知道前1000项是匹配的，它就会从W的第**1001**项开始重新查。

## 原理

### KMP本身

KMP 用两个指针（j，k）分别查两个数组（S， W）。

当`S[j] === W[k]`时，两个指针都向后移动一位。 如果`k === W.length`,说明W在S中完全匹配，返回W首字符在S中的位置（j - k）。

当`S[j] !== W[k]`时，我们想知道W中**前k-1项及其子字符串**曾在W哪里出现，并移动到那个位置的**后一位**。我们使用一个辅助数组T来记录，所以指针k`k = T[k]`。如果`k === -1`，说明在W中**第k-1项**从来没重复过，k移动到W的**头部**，j向后移动一位， 重头查。

如果`j === S.length`还没返回，则说明W没有在S中匹配，返回-1，表示没找到。

### 数组T

在跑上述算法前，我们要先生成T。这是KMP的难点。

W的首字符不可能在W中出现， 所以`T[0] = -1`。

我们使用两个指针。pos用来遍历W，cnd用来记录*候选子字符串*的**下一个字符的位置**。候选子字符串为`W[0..cnd-1]`。比如`a b c d a b d`, 最后一个d对应在T中的值是2。因为d前的ab（候选子字符串）在之前出现过。

如果`W[pos] === W[cnd]`, 则`T[pos] = T[cnd]； cnd++；` 这表示，候选子字符串**不要缩短**, 并要延长一位（把`W[pos]`对应的字符加入到候选子字符串）。

如果`W[pos] !== W[cnd]`, 则`T[pos] = cnd`。 这表示，字符串遍历到pos时，候选子字符串**要缩短**。我们先记录下当前cnd（`T[pos] = cnd`），然后重新寻找候选子字符串(cnd 满足`cnd >= 0 || W[pos] === W[cnd])`)。因为cnd表示候选子字符串的**下一个字符的位置**， 所以`cnd++`。

在两种情况中，`T[pos]都被设置了，所以后移pos（pos++）。


## 边界条件

当`W = ""`时，不管S是什么，直接返回0。因为所有字符串的首位，都是""。
