# 学习笔记

## 广度优先搜索（BFS）vs 深度优先搜索（DFS）

### 原理
 * BFS优先搜索节点的**所有子节点**。
 * DFS优先搜索节点的**一个分支**。

### 实现
* BFS利用**队列**。搜索完一个节点，该节点出队，它的所有子节点入队。
* DFS利用**栈**（递归本质就是栈）。搜索完一个节点，该节点出栈，它的所有子节点入栈。

## 最小堆

### 原理
最小堆是个**满二叉树**（除了叶子节点和在倒数第二层的节点，所有节点都有2个子节点， 且尽最大可能使倒数第二层的**左侧**节点填满子节点）。由于这个性质，最小堆的值可以使用数组来存储。例如，对于数组内第*i*个元素：
* 夫亲节点： （i - 1）/ 2
* 左孩子节点： 2 * i + 1
* 右孩子节点： 2 * i + 2

**最小堆**及其**子树**满足：父亲节点的值小于子节点的值。

### 应用：（堆排序，优先级队列）

常用方法

* 排序：将节点与其**左右**子节点分别比较， 如果比他们大， 交换，然后对交换过的子节点进行递归。

* 插入： 将新元素插入数组**最后一个**位置。然后与其**父亲节点**比较，如果比它的值小，**两者交换**。继续这样的比较直到满足最小堆的性质。

* 移除：找到想要移除的元素，与**最后一个**元素交换， 重新排该**子树**

* 取出最小值：返回根节点的值，然后移除根节点再排序

## A* 算法

源于[维基百科](https://en.wikipedia.org/wiki/A*_search_algorithm)

### 原理

该算法通过**预估**来指导搜索。它的核心为：`f(n) = g(n) + h(n)`

* `f(n)`: 移动到n点的**总**消耗
* `g(n)`：移动到n点的**实际**消耗
* `h(n)`：移动到n点的**预估**消耗

以本项目为例，g(n)为起点到n点的**实际距离（受障碍物的影响）**，h(n)为n点到重点的**预估距离（不受障碍物影响）**。

老师给的例子简化了算法，它忽略了实际距离，既： `f(n) = h(n)`。影响是， 遇到**环形**障碍物时，路径不是最优。（老师的算法有点像倒香槟塔的感觉，上层杯子满了才会溢出流到下层）

## 细节

1.null vs undefinded

这是js的两种**不同**的数据类型. `null` is type of `Object`, `undefinded` is type of `undefinded` 

## 问题

老师在最后一节寻路课上提到， 插入最小堆中， 有优化，但我没有想出来。请问怎么优化 ？

我理解的是，所有**两点间**的距离都是**1**。（我简化了地图，只允许上下左右移动，距离是L1范数）这样的话，**后**访问到的点是不可能比**先**访问到的拥有**更小的实际距离**，代码也就没有改动了。
